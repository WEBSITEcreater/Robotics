#pragma config(Sensor, port1,  topSensor,      sensorVexIQ_Gyro)
#pragma config(Sensor, port2,  leftLED,        sensorVexIQ_LED)
#pragma config(Sensor, port6,  leftSensor,     sensorVexIQ_ColorGrayscale)
#pragma config(Sensor, port8,  rightLED,       sensorVexIQ_LED)
#pragma config(Sensor, port10, FrontSensor,    sensorVexIQ_Distance)
#pragma config(Sensor, port12, rightSensor,    sensorVexIQ_ColorGrayscale)
#pragma config(Motor,  motor5,          leftMotor,     tmotorVexIQ, PIDControl, driveLeft, encoder)
#pragma config(Motor,  motor11,         rightMotor,    tmotorVexIQ, PIDControl, reversed, driveRight, encoder)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

float leftStick;
float rightStick;
float leftFinal;
float rightFinal;

int counter = 0;
int degrees;
float distance;
float distanceRaw;

task main(){
	while(true){

		distanceRaw = getDistanceValue(FrontSensor);
		distance = distanceRaw / 25.4;

		degrees = getGyroDegrees(topSensor);

		if(vexRT[BtnFUp]){
			counter = 1;
		}
		else if(vexRT[BtnFDown]){
			counter = 0;
		}
		if(vexRT[BtnEUp]){
			leftFinal = 30;
			rightFinal = 30;
			while(vexRT[BtnEDown] == 0){
				if(getColorValue(leftSensor) < 350){
					leftFinal -= 1;
					wait1Msec(4);
				}
				else{

					leftFinal = 30;

				}
				if(getColorValue(rightSensor) < 350){
					rightFinal -= 1;
					wait1Msec(4);
				}
				else{

					rightFinal = 30;

				}
				setMotorSpeed(leftMotor, leftFinal);
				setMotorSpeed(rightMotor, rightFinal);
			}
		}

		if(vexRT[BtnLUp]){
			while(vexRT[BtnLDown] == 0){
				distanceRaw = getDistanceValue(FrontSensor);
				distance = distanceRaw / 25.4;

				if(distance < 8){
					setMotorSpeed(leftMotor, -50);
					setMotorSpeed(rightMotor, -50);
					wait1Msec(750);
					setMotorSpeed(leftMotor, 0);
					setMotorSpeed(rightMotor, 0);

					wait1Msec(250);
					resetGyro(topSensor);
					int randTurn = random(280);
					int turn = getGyroDegrees(topSensor);
					while(turn < randTurn){
						setMotorSpeed(leftMotor, -50);
						setMotorSpeed(rightMotor, 50);
						turn = getGyroDegrees(topSensor);
						wait1Msec(25);
					}
					setMotorSpeed(leftMotor, 0);
					setMotorSpeed(rightMotor, 0);
				}
				else{
					setMotorSpeed(leftMotor, 75);
					setMotorSpeed(rightMotor, 75);
				}
			}
		}



		if(counter == 0){
			leftStick = vexRT[ChA] * vexRT[ChA];
			rightStick = vexRT[ChD] * vexRT[ChD];

			leftFinal = leftStick / 100;
			rightFinal = rightStick / 100;

			if(vexRT(ChA) < 0){
				leftFinal = leftFinal * -1;
			}
			if(vexRT(ChD) < 0){
				rightFinal = rightFinal * -1;
			}
		}
		else if(counter == 1) {
			leftFinal = vexRT[ChA];
			rightFinal = vexRT[ChD];
		}

		setMotorSpeed(leftMotor, leftFinal);
		setMotorSpeed(rightMotor, rightFinal);
		displayCenteredTextLine(0, "Hue %f", getColorValue(leftSensor));
		displayCenteredTextLine(1, "Counter %d", counter);
		//displayCenteredTextLine(2, "right %f", rightFinal);
		//displayCenteredTextLine(3, "left %f", leftFinal);
		displayCenteredTextLine(2, "Ditance %f inches", distance);
		displayCenteredTextLine(3, "Rotation %d degrees", degrees);

		if(leftFinal > 0){
			setTouchLEDColor(leftLED, colorGreen);
			setTouchLEDBrightness(leftLED, leftFinal);
		}
		else if(leftFinal < 0){
			setTouchLEDColor(leftLED, colorRed);
			setTouchLEDBrightness(leftLED, (-1 * leftFinal));
		}
		else{
			setTouchLEDColor(leftLED, colorBlue);
			setTouchLEDBrightness(leftLED, 100);
		}
		if(rightFinal > 0){
			setTouchLEDColor(rightLED, colorGreen);
			setTouchLEDBrightness(rightLED, leftFinal);
		}
		else if(rightFinal < 0){
			setTouchLEDColor(rightLED, colorRed);
			setTouchLEDBrightness(rightLED, (-1 * leftFinal));
		}
		else{
			setTouchLEDColor(rightLED, colorBlue);
			setTouchLEDBrightness(rightLED, 100);
		}
		//if(distance < 8){
		//	setMotorSpeed(leftMotor, -100);
		//	setMotorSpeed(rightMotor, -100);
		//	wait1Msec(1000);
		//}
		if(vexRT[BtnRUp]){
			resetGyro(topSensor);
		}
	}
}
